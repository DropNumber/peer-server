// Generated by CoffeeScript 1.6.2
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.WebRTC = (function() {
    function WebRTC() {
      this.createDataChannel = __bind(this.createDataChannel, this);
      this.createServerConnection = __bind(this.createServerConnection, this);
      this.receiveAnswer = __bind(this.receiveAnswer, this);
      var _this = this;

      this.connection = io.connect("http://localhost:8890");
      this.connection.emit('joinAsClient');
      this.createServerConnection();
      this.createDataChannel();
      this.sendOffer();
      this.connection.on("receiveAnswer", this.receiveAnswer);
      this.connection.on("receiveICECandidate", function(candidate) {
        console.log("receive_ice_candidate", candidate);
        if (candidate) {
          candidate = new RTCIceCandidate(candidate);
          console.log(candidate);
          return _this.serverRTCPC.addIceCandidate(candidate);
        }
      });
    }

    WebRTC.prototype.sendOffer = function() {
      var _this = this;

      return this.serverRTCPC.createOffer(function(sessionDescription) {
        _this.serverRTCPC.setLocalDescription(sessionDescription);
        return _this.connection.emit("sendOffer", sessionDescription);
      });
    };

    WebRTC.prototype.receiveAnswer = function(sessionDescription) {
      console.log("receive answer", sessionDescription);
      return this.serverRTCPC.setRemoteDescription(new RTCSessionDescription(sessionDescription));
    };

    WebRTC.prototype.createServerConnection = function() {
      var _this = this;

      this.serverRTCPC = new RTCPeerConnection(null, {
        "optional": [
          {
            "RtpDataChannels": true
          }
        ]
      });
      return this.serverRTCPC.onicecandidate = function(event) {
        return _this.connection.emit("sendICECandidate", "server", event.candidate);
      };
    };

    WebRTC.prototype.createDataChannel = function() {
      var error,
        _this = this;

      try {
        console.log("createDataChannel to server");
        this.dataChannel = this.serverRTCPC.createDataChannel("RTCDataChannel", {
          reliable: false
        });
        this.dataChannel.onopen = function() {
          return console.log("data stream open");
        };
        this.dataChannel.onclose = function(event) {
          return console.log("data stream close");
        };
        this.dataChannel.onmessage = function(message) {
          console.log("data stream message");
          console.log(message);
          return _this.receiveEvent(message.data);
        };
        return this.dataChannel.onerror = function(err) {
          return console.log("data stream error: " + err);
        };
      } catch (_error) {
        error = _error;
        console.log("seems that DataChannel is NOT actually supported!");
        throw error;
      }
    };

    WebRTC.prototype.receiveEvent = function(messageEventData) {
      var eventName, messageData;

      messageEventData = JSON.parse(messageEventData);
      eventName = messageEventData.eventName;
      messageData = messageEventData.data;
      if (this.onMessageCallback) {
        this.onMessageCallback(messageData);
      }
    };

    return WebRTC;

  })();

}).call(this);
