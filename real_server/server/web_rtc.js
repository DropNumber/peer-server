// Generated by CoffeeScript 1.6.2
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.WebRTC = (function() {
    function WebRTC() {
      this.sendEvent = __bind(this.sendEvent, this);
      this.receiveOffer = __bind(this.receiveOffer, this);
      this.addPeerConnection = __bind(this.addPeerConnection, this);
      var _this = this;

      this.peerConnections = {};
      this.dataChannels = {};
      this.connection = io.connect("http://localhost:8890");
      this.connection.emit('joinAsServer');
      this.connection.on('joined', function(clientID) {
        _this.addPeerConnection(clientID);
        return console.log('client joined', clientID);
      });
      this.connection.on("receiveOffer", this.receiveOffer);
      this.connection.on("receiveICECandidate", function(clientID, candidate) {
        console.log("receive_ice_candidate", candidate);
        if (candidate) {
          candidate = new RTCIceCandidate(candidate);
          console.log(candidate);
          return _this.peerConnections[clientID].addIceCandidate(candidate);
        }
      });
    }

    WebRTC.prototype.addPeerConnection = function(clientID) {
      var pc,
        _this = this;

      pc = new RTCPeerConnection(null, {
        "optional": [
          {
            "RtpDataChannels": true
          }
        ]
      });
      this.peerConnections[clientID] = pc;
      pc.onicecandidate = function(event) {
        console.log("onicecandidate");
        return _this.connection.emit("sendICECandidate", clientID, event.candidate);
      };
      pc.ondatachannel = function(evt) {
        console.log('data channel connecting ' + clientID);
        _this.addDataChannel(clientID, evt.channel);
      };
    };

    WebRTC.prototype.receiveOffer = function(clientID, sdp) {
      var pc;

      console.log("offer received from " + clientID);
      pc = this.peerConnections[clientID];
      pc.setRemoteDescription(new RTCSessionDescription(sdp));
      this.sendAnswer(clientID);
    };

    WebRTC.prototype.sendAnswer = function(clientID) {
      var pc,
        _this = this;

      console.log("sendAnswer");
      pc = this.peerConnections[clientID];
      pc.createAnswer(function(session_description) {
        pc.setLocalDescription(session_description);
        console.log("sendAnswer emit");
        return _this.connection.emit("sendAnswer", clientID, session_description);
      });
    };

    WebRTC.prototype.addDataChannel = function(clientID, channel) {
      var _this = this;

      console.log("adding data channel");
      channel.onopen = function() {
        return console.log("data stream open " + clientID);
      };
      channel.onclose = function(event) {
        delete _this.dataChannels[clientID];
        return console.log("data stream close " + clientID);
      };
      channel.onmessage = function(message) {
        console.log("data stream message " + clientID);
        return console.log(message);
      };
      channel.onerror = function(err) {
        return console.log("data stream error " + clientID + ": " + err);
      };
      this.dataChannels[clientID] = channel;
      return channel;
    };

    WebRTC.prototype.sendEvent = function(eventName, data) {
      var clientID, dataChannel, _ref;

      _ref = this.dataChannels;
      for (clientID in _ref) {
        dataChannel = _ref[clientID];
        console.log("send event " + eventName);
        dataChannel.send(JSON.stringify({
          "eventName": eventName,
          "data": data
        }));
        return;
      }
    };

    return WebRTC;

  })();

}).call(this);
