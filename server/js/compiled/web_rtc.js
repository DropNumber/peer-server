// Generated by CoffeeScript 1.6.1
(function() {
  "WebRTC handler for clientServer.\n\nDispatches (sends and receives) WebRTC data. Should be kept \nas minimal as possible, dispatching to other modules.";
  var _this = this;

  window.WebRTC = (function() {

    function WebRTC(serverFileCollection, setClientBrowserLink) {
      var _this = this;
      this.serverFileCollection = serverFileCollection;
      this.setClientBrowserLink = setClientBrowserLink;
      this.evalDynamic = function(js) {
        return WebRTC.prototype.evalDynamic.apply(_this, arguments);
      };
      this.getContentsForPath = function(path) {
        return WebRTC.prototype.getContentsForPath.apply(_this, arguments);
      };
      this.serveFile = function(data) {
        return WebRTC.prototype.serveFile.apply(_this, arguments);
      };
      this.serveAjax = function(data) {
        return WebRTC.prototype.serveAjax.apply(_this, arguments);
      };
      this.setUpReceiveEventCallbacks = function() {
        return WebRTC.prototype.setUpReceiveEventCallbacks.apply(_this, arguments);
      };
      this.sendEventTo = function(socketId, eventName, data) {
        return WebRTC.prototype.sendEventTo.apply(_this, arguments);
      };
      this.sendEvent = function(eventName, data) {
        return WebRTC.prototype.sendEvent.apply(_this, arguments);
      };
      this.receiveICECandidate = function(socketID, candidate) {
        return WebRTC.prototype.receiveICECandidate.apply(_this, arguments);
      };
      this.receiveOffer = function(socketID, sdp) {
        return WebRTC.prototype.receiveOffer.apply(_this, arguments);
      };
      this.addBrowserConnection = function(socketID) {
        return WebRTC.prototype.addBrowserConnection.apply(_this, arguments);
      };
      this.getSocketId = function() {
        return WebRTC.prototype.getSocketId.apply(_this, arguments);
      };
      this.browserConnections = {};
      this.dataChannels = {};
      this.eventTransmitter = new window.EventTransmitter();
      this.setUpReceiveEventCallbacks();
      this.connection = io.connect(document.location.origin);
      this.connection.emit("joinAsClientServer");
      this.connection.on("joined", this.addBrowserConnection);
      this.connection.on("receiveOffer", this.receiveOffer);
      this.connection.on("receiveICECandidate", this.receiveICECandidate);
      this.connection.on("setSocketId", function(socketId) {
        console.log("SERVER SOCKET ID: " + socketId);
        _this.socketId = socketId;
        return _this.setClientBrowserLink(window.location.origin + "/connect/" + socketId + "/");
      });
    }

    WebRTC.prototype.getSocketId = function() {
      return this.socketId;
    };

    WebRTC.prototype.addDataChannel = function(socketID, channel) {
      var _this = this;
      console.log("adding data channel");
      channel.onopen = function() {
        var landingPage;
        console.log("data stream open " + socketID);
        landingPage = _this.serverFileCollection.getLandingPage();
        return channel.send(JSON.stringify({
          "eventName": "initialLoad",
          "data": landingPage
        }));
      };
      channel.onclose = function(event) {
        delete _this.dataChannels[socketID];
        return console.log("data stream close " + socketID);
      };
      channel.onmessage = function(message) {
        console.log("data stream message " + socketID);
        console.log(message);
        return _this.eventTransmitter.receiveEvent(message.data);
      };
      channel.onerror = function(err) {
        return console.log("data stream error " + socketID + ": " + err);
      };
      return this.dataChannels[socketID] = channel;
    };

    WebRTC.prototype.addBrowserConnection = function(socketID) {
      var peerConnection,
        _this = this;
      peerConnection = new mozRTCPeerConnection(null, {
        "optional": [
          {
            "RtpDataChannels": true
          }
        ]
      });
      this.browserConnections[socketID] = peerConnection;
      peerConnection.onicecandidate = function(event) {
        return _this.connection.emit("sendICECandidate", socketID, event.candidate);
      };
      peerConnection.ondatachannel = function(evt) {
        console.log("data channel connecting " + socketID);
        return _this.addDataChannel(socketID, evt.channel);
      };
      return console.log("client joined", socketID);
    };

    WebRTC.prototype.receiveOffer = function(socketID, sdp) {
      var pc;
      console.log("offer received from " + socketID);
      pc = this.browserConnections[socketID];
      pc.setRemoteDescription(new mozRTCSessionDescription(sdp));
      return this.sendAnswer(socketID);
    };

    WebRTC.prototype.sendAnswer = function(socketID) {
      var pc,
        _this = this;
      pc = this.browserConnections[socketID];
      return pc.createAnswer(function(session_description) {
        pc.setLocalDescription(session_description);
        return _this.connection.emit("sendAnswer", socketID, session_description);
      });
    };

    WebRTC.prototype.receiveICECandidate = function(socketID, candidate) {
      if (candidate) {
        candidate = new mozRTCIceCandidate(candidate);
        console.log(candidate);
        return this.browserConnections[socketID].addIceCandidate(candidate);
      }
    };

    WebRTC.prototype.sendEvent = function(eventName, data) {
      var dataChannel, socketID, _ref, _results;
      _ref = this.dataChannels;
      _results = [];
      for (socketID in _ref) {
        dataChannel = _ref[socketID];
        _results.push(this.eventTransmitter.sendEvent(dataChannel, eventName, data));
      }
      return _results;
    };

    WebRTC.prototype.sendEventTo = function(socketId, eventName, data) {
      this.eventTransmitter.sendEvent(this.dataChannels[socketId], eventName, data);
      console.log("sending event");
      return console.log(data);
    };

    WebRTC.prototype.setUpReceiveEventCallbacks = function() {
      this.eventTransmitter.addEventCallback("requestFile", this.serveFile);
      return this.eventTransmitter.addEventCallback("requestAjax", this.serveAjax);
    };

    WebRTC.prototype.serveAjax = function(data) {
      var path, response;
      console.log("Got an ajax request");
      console.log(data);
      if (!('path' in data)) {
        console.log("Received bad ajax request: no path requested");
        return;
      }
      path = data['path'];
      if (!this.serverFileCollection.hasFile(path)) {
        console.log("Path not found");
        return;
      }
      response = {};
      if ('requestId' in data) {
        response['requestId'] = data['requestId'];
      }
      response['path'] = path;
      response['contents'] = this.getContentsForPath(path);
      console.log("Transmitting ajax response");
      console.log(response);
      return this.sendEventTo(data.socketId, "receiveAjax", response);
    };

    WebRTC.prototype.serveFile = function(data) {
      var page404, path;
      console.log("FILENAME: " + data.filename);
      path = data.filename;
      if (!this.serverFileCollection.hasFile(path)) {
        page404 = this.serverFileCollection.get404Page();
        console.error("Error: Client requested " + path + " which does not exist on server.");
        this.sendEventTo(data.socketId, "receiveFile", {
          filename: page404.filename,
          fileContents: page404.fileContents,
          fileType: page404.type,
          type: data.type
        });
        return;
      }
      return this.sendEventTo(data.socketId, "receiveFile", {
        filename: path,
        fileContents: this.getContentsForPath(path),
        type: data.type,
        fileType: this.serverFileCollection.getFileType(path)
      });
    };

    WebRTC.prototype.getContentsForPath = function(path) {
      var contents;
      contents = "";
      if (this.serverFileCollection.isDynamic(path)) {
        return contents = this.evalDynamic(this.serverFileCollection.getContents(path));
      } else {
        return contents = this.serverFileCollection.getContents(path);
      }
    };

    WebRTC.prototype.evalDynamic = function(js) {
      var exe,
        _this = this;
      console.log("evalDynamic");
      exe = function() {
        var serverFileCollection;
        serverFileCollection = _this.serverFileCollection;
        return eval(js);
      };
      return exe();
    };

    return WebRTC;

  })();

}).call(this);
