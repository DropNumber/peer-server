// Generated by CoffeeScript 1.6.2
(function() {
  "WebRTC handler for clientServer.\n\nDispatches (sends and receives) WebRTC data. Should be kept \nas minimal as possible, dispatching to other modules.";
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.WebRTC = (function() {
    function WebRTC(serverFileCollection, setClientBrowserLink) {
      var _this = this;

      this.serverFileCollection = serverFileCollection;
      this.setClientBrowserLink = setClientBrowserLink;
      this.evalDynamic = __bind(this.evalDynamic, this);
      this.serveFile = __bind(this.serveFile, this);
      this.serveAjax = __bind(this.serveAjax, this);
      this.setUpReceiveEventCallbacks = __bind(this.setUpReceiveEventCallbacks, this);
      this.sendEventTo = __bind(this.sendEventTo, this);
      this.sendEvent = __bind(this.sendEvent, this);
      this.receiveICECandidate = __bind(this.receiveICECandidate, this);
      this.receiveOffer = __bind(this.receiveOffer, this);
      this.addBrowserConnection = __bind(this.addBrowserConnection, this);
      this.getSocketId = __bind(this.getSocketId, this);
      this.browserConnections = {};
      this.dataChannels = {};
      this.eventTransmitter = new window.EventTransmitter();
      this.setUpReceiveEventCallbacks();
      this.connection = io.connect(document.location.origin);
      this.connection.emit("joinAsClientServer");
      this.connection.on("joined", this.addBrowserConnection);
      this.connection.on("receiveOffer", this.receiveOffer);
      this.connection.on("receiveICECandidate", this.receiveICECandidate);
      this.connection.on("setSocketId", function(socketId) {
        console.log("SERVER SOCKET ID: " + socketId);
        _this.socketId = socketId;
        return _this.setClientBrowserLink(window.location.origin + "/connect/" + socketId + "/");
      });
    }

    WebRTC.prototype.getSocketId = function() {
      return this.socketId;
    };

    WebRTC.prototype.addDataChannel = function(socketID, channel) {
      var _this = this;

      console.log("adding data channel");
      channel.onopen = function() {
        var landingPage;

        console.log("data stream open " + socketID);
        landingPage = _this.serverFileCollection.getLandingPage();
        return channel.send(JSON.stringify({
          "eventName": "initialLoad",
          "data": landingPage
        }));
      };
      channel.onclose = function(event) {
        delete _this.dataChannels[socketID];
        return console.log("data stream close " + socketID);
      };
      channel.onmessage = function(message) {
        console.log("data stream message " + socketID);
        console.log(message);
        return _this.eventTransmitter.receiveEvent(message.data);
      };
      channel.onerror = function(err) {
        return console.log("data stream error " + socketID + ": " + err);
      };
      return this.dataChannels[socketID] = channel;
    };

    WebRTC.prototype.addBrowserConnection = function(socketID) {
      var peerConnection,
        _this = this;

      peerConnection = new mozRTCPeerConnection(null, {
        "optional": [
          {
            "RtpDataChannels": true
          }
        ]
      });
      this.browserConnections[socketID] = peerConnection;
      peerConnection.onicecandidate = function(event) {
        return _this.connection.emit("sendICECandidate", socketID, event.candidate);
      };
      peerConnection.ondatachannel = function(evt) {
        console.log("data channel connecting " + socketID);
        return _this.addDataChannel(socketID, evt.channel);
      };
      return console.log("client joined", socketID);
    };

    WebRTC.prototype.receiveOffer = function(socketID, sdp) {
      var pc;

      console.log("offer received from " + socketID);
      pc = this.browserConnections[socketID];
      pc.setRemoteDescription(new mozRTCSessionDescription(sdp));
      return this.sendAnswer(socketID);
    };

    WebRTC.prototype.sendAnswer = function(socketID) {
      var pc,
        _this = this;

      pc = this.browserConnections[socketID];
      return pc.createAnswer(function(session_description) {
        pc.setLocalDescription(session_description);
        return _this.connection.emit("sendAnswer", socketID, session_description);
      });
    };

    WebRTC.prototype.receiveICECandidate = function(socketID, candidate) {
      if (candidate) {
        candidate = new mozRTCIceCandidate(candidate);
        console.log(candidate);
        return this.browserConnections[socketID].addIceCandidate(candidate);
      }
    };

    WebRTC.prototype.sendEvent = function(eventName, data) {
      var dataChannel, socketID, _ref, _results;

      _ref = this.dataChannels;
      _results = [];
      for (socketID in _ref) {
        dataChannel = _ref[socketID];
        _results.push(this.eventTransmitter.sendEvent(dataChannel, eventName, data));
      }
      return _results;
    };

    WebRTC.prototype.sendEventTo = function(socketId, eventName, data) {
      this.eventTransmitter.sendEvent(this.dataChannels[socketId], eventName, data);
      console.log("sending event");
      return console.log(data);
    };

    WebRTC.prototype.setUpReceiveEventCallbacks = function() {
      this.eventTransmitter.addEventCallback("requestFile", this.serveFile);
      return this.eventTransmitter.addEventCallback("requestAjax", this.serveAjax);
    };

    WebRTC.prototype.serveAjax = function(data) {
      var path, response;

      console.log("Got an ajax request");
      console.log(data);
      if (!('path' in data)) {
        console.log("Received bad ajax request: no path requested");
        return;
      }
      path = data['path'];
      if (!this.serverFileCollection.hasFile(path)) {
        console.log("Path not found");
        return;
      }
      response = {};
      if ('requestId' in data) {
        response['requestId'] = data['requestId'];
      }
      response['path'] = path;
      if (this.serverFileCollection.isDynamic(path)) {
        response['contents'] = this.evalDynamic(this.serverFileCollection.getContents(path));
      } else {
        response['contents'] = this.serverFileCollection.getContents(path);
      }
      console.log("Transmitting ajax response");
      console.log(response);
      return this.sendEventTo(data.socketId, "receiveAjax", response);
    };

    WebRTC.prototype.serveFile = function(data) {
      var filename, responseContents;

      filename = data.filename;
      console.log("FILENAME: " + filename);
      if (!this.serverFileCollection.hasFile(filename)) {
        console.error("Error: Client requested " + filename + " which does not exist on server.");
        this.sendEventTo(data.socketId, "receiveFile", {
          filename: filename,
          fileContents: "",
          type: ""
        });
        return;
      }
      responseContents = "";
      if (this.serverFileCollection.isDynamic(filename)) {
        responseContents = this.evalDynamic(this.serverFileCollection.getContents(filename));
      } else {
        responseContents = this.serverFileCollection.getContents(filename);
      }
      return this.sendEventTo(data.socketId, "receiveFile", {
        filename: filename,
        fileContents: responseContents,
        type: data.type
      });
    };

    WebRTC.prototype.evalDynamic = function(js) {
      var exe,
        _this = this;

      exe = function() {
        var serverFileCollection;

        serverFileCollection = _this.serverFileCollection;
        return eval(js);
      };
      return exe();
    };

    return WebRTC;

  })();

}).call(this);
