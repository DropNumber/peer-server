// Generated by CoffeeScript 1.6.2
(function() {
  " \nWebRTC handler for clientBrowser. \n\n(TODO at some point refactor)";
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.WebRTC = (function() {
    function WebRTC(documentElement) {
      this.executeScriptsCallback = __bind(this.executeScriptsCallback, this);
      this.setDocumentElementInnerHTML = __bind(this.setDocumentElementInnerHTML, this);
      this.setUpReceiveEventCallbacks = __bind(this.setUpReceiveEventCallbacks, this);
      this.sendEvent = __bind(this.sendEvent, this);
      this.receiveICECandidate = __bind(this.receiveICECandidate, this);
      this.receiveAnswer = __bind(this.receiveAnswer, this);
      this.sendOffer = __bind(this.sendOffer, this);
      this.createServerConnection = __bind(this.createServerConnection, this);
      this.createDataChannel = __bind(this.createDataChannel, this);
      this.parseUrl = __bind(this.parseUrl, this);
      this.getSocketId = __bind(this.getSocketId, this);
      var startPage, _ref,
        _this = this;

      this.documentElement = documentElement;
      this.connection = io.connect(window.location.origin);
      _ref = this.parseUrl(window.location.pathname), this.desiredServer = _ref[0], startPage = _ref[1];
      this.connection.emit("joinAsClientBrowser", {
        "desiredServer": this.desiredServer
      });
      this.pathRoot = "/connect/" + this.desiredServer + "/";
      this.serverRTCPC = null;
      this.createServerConnection();
      this.createDataChannel();
      this.sendOffer(this.desiredServer);
      this.connection.on("receiveAnswer", this.receiveAnswer);
      this.connection.on("receiveICECandidate", this.receiveICECandidate);
      this.connection.on("setSocketId", function(socketId) {
        return _this.socketId = socketId;
      });
      this.htmlProcessor = new HTMLProcessor(this.sendEvent, this.setDocumentElementInnerHTML, this.getSocketId);
      this.ajaxClient = new AJAXClient(this.sendEvent, this.getSocketId);
      this.eventTransmitter = new EventTransmitter();
      this.setUpReceiveEventCallbacks(startPage);
      window.onpopstate = function(evt) {
        var filename;

        filename = evt.state.path;
        return _this.htmlProcessor.requestFile(filename, "backbutton");
      };
    }

    WebRTC.prototype.getSocketId = function() {
      return this.socketId;
    };

    WebRTC.prototype.parseUrl = function(pathname) {
      var serverId, slashIndex, startPage, suffix;

      if (pathname.indexOf("connect") === -1) {
        console.error("Error: pathname does not contain 'connect'");
      }
      suffix = pathname.substr("/connect/".length);
      slashIndex = suffix.indexOf("/");
      startPage = null;
      if (slashIndex !== -1) {
        serverId = suffix.substr(0, slashIndex);
        if (slashIndex !== (suffix.length - 1)) {
          startPage = suffix.substr(suffix.indexOf("/") + 1);
        }
      } else {
        serverId = suffix;
      }
      return [serverId, startPage];
    };

    WebRTC.prototype.createDataChannel = function() {
      var error,
        _this = this;

      try {
        console.log("createDataChannel to server");
        this.dataChannel = this.serverRTCPC.createDataChannel("RTCDataChannel", {
          reliable: false
        });
        this.dataChannel.onopen = function() {
          console.log("data stream open");
          return _this.sendEvent("testEvent", {});
        };
        this.dataChannel.onclose = function(event) {
          return console.log("data stream close");
        };
        this.dataChannel.onmessage = function(message) {
          console.log("data stream message");
          return _this.eventTransmitter.receiveEvent(message.data);
        };
        return this.dataChannel.onerror = function(err) {
          return console.log("data stream error: " + err);
        };
      } catch (_error) {
        error = _error;
        return console.error("seems that DataChannel is NOT actually supported!");
      }
    };

    WebRTC.prototype.createServerConnection = function() {
      var _this = this;

      this.serverRTCPC = new mozRTCPeerConnection(null, {
        "optional": [
          {
            "RtpDataChannels": true
          }
        ]
      });
      return this.serverRTCPC.onicecandidate = function(event) {
        return _this.connection.emit("sendICECandidate", "server", event.candidate);
      };
    };

    WebRTC.prototype.sendOffer = function(desiredServer) {
      var _this = this;

      return this.serverRTCPC.createOffer(function(sessionDescription) {
        _this.serverRTCPC.setLocalDescription(sessionDescription);
        return _this.connection.emit("sendOffer", sessionDescription, desiredServer);
      });
    };

    WebRTC.prototype.receiveAnswer = function(sessionDescription) {
      return this.serverRTCPC.setRemoteDescription(new mozRTCSessionDescription(sessionDescription));
    };

    WebRTC.prototype.receiveICECandidate = function(candidate) {
      if (candidate) {
        candidate = new mozRTCIceCandidate(candidate);
        console.log(candidate);
        return this.serverRTCPC.addIceCandidate(candidate);
      }
    };

    WebRTC.prototype.sendEvent = function(eventName, data) {
      return this.eventTransmitter.sendEvent(this.dataChannel, eventName, data);
    };

    WebRTC.prototype.setUpReceiveEventCallbacks = function(startPage) {
      var _this = this;

      this.eventTransmitter.addEventCallback("initialLoad", function(data) {
        if (startPage) {
          startPage = _this.htmlProcessor.removeTrailingSlash(startPage);
          return _this.htmlProcessor.requestFile(startPage, "initialLoad");
        } else {
          return _this.setDocumentElementInnerHTML(data, "initialLoadDefault");
        }
      });
      this.eventTransmitter.addEventCallback("textAreaValueChanged", this.setDocumentElementInnerHTML);
      this.eventTransmitter.addEventCallback("receiveFile", this.htmlProcessor.receiveFile);
      return this.eventTransmitter.addEventCallback("receiveAjax", this.ajaxClient.receiveAjax);
    };

    WebRTC.prototype.setDocumentElementInnerHTML = function(data, optionalInfo) {
      var fullPath, html, path,
        _this = this;

      html = data.fileContents;
      path = this.htmlProcessor.removeTrailingSlash(data.filename);
      console.log(path);
      if (optionalInfo !== "backbutton" && optionalInfo !== "initialLoad") {
        fullPath = this.pathRoot + path;
        window.history.pushState({
          "path": path
        }, fullPath, fullPath);
        console.log(window.history.state);
      }
      this.documentElement.innerHTML = "";
      return this.htmlProcessor.processHTML(html, function(processedHTML, scriptMapping) {
        _this.documentElement.innerHTML = processedHTML;
        return _this.executeScriptsCallback(scriptMapping);
      });
    };

    WebRTC.prototype.executeScriptsCallback = function(scriptMapping) {
      var filename, newScriptEl, oldScriptEl, scriptElements, _i, _len, _results;

      scriptElements = this.documentElement.getElementsByTagName("script");
      _results = [];
      for (_i = 0, _len = scriptElements.length; _i < _len; _i++) {
        oldScriptEl = scriptElements[_i];
        newScriptEl = document.createElement("script");
        newScriptEl.type = "text/javascript";
        filename = oldScriptEl.text || oldScriptEl.textContent || oldScriptEl.innerHTML || "";
        if (!scriptMapping[filename]) {
          console.error("BAD: " + filename + "was not found in the script mapping. Script will not exist. This is because the script name got encoding-bork.");
        }
        newScriptEl.text = scriptMapping[filename];
        oldScriptEl.parentNode.insertBefore(newScriptEl, oldScriptEl);
        _results.push(oldScriptEl.parentNode.removeChild(oldScriptEl));
      }
      return _results;
    };

    return WebRTC;

  })();

}).call(this);
