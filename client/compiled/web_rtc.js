// Generated by CoffeeScript 1.6.1
(function() {
  " \nWebRTC handler for clientBrowser. \n\n(TODO at some point refactor)";
  var _this = this;

  window.WebRTC = (function() {

    function WebRTC(documentElement) {
      var contentWindow, desiredServer,
        _this = this;
      this.executeScriptsCallback = function(scriptMapping) {
        return WebRTC.prototype.executeScriptsCallback.apply(_this, arguments);
      };
      this.setDocumentElementInnerHTML = function(data, optionalInfo) {
        return WebRTC.prototype.setDocumentElementInnerHTML.apply(_this, arguments);
      };
      this.setUpReceiveEventCallbacks = function() {
        return WebRTC.prototype.setUpReceiveEventCallbacks.apply(_this, arguments);
      };
      this.sendEvent = function(eventName, data) {
        return WebRTC.prototype.sendEvent.apply(_this, arguments);
      };
      this.receiveICECandidate = function(candidate) {
        return WebRTC.prototype.receiveICECandidate.apply(_this, arguments);
      };
      this.receiveAnswer = function(sessionDescription) {
        return WebRTC.prototype.receiveAnswer.apply(_this, arguments);
      };
      this.sendOffer = function(desiredServer) {
        return WebRTC.prototype.sendOffer.apply(_this, arguments);
      };
      this.createServerConnection = function() {
        return WebRTC.prototype.createServerConnection.apply(_this, arguments);
      };
      this.createDataChannel = function() {
        return WebRTC.prototype.createDataChannel.apply(_this, arguments);
      };
      this.getDesiredServer = function() {
        return WebRTC.prototype.getDesiredServer.apply(_this, arguments);
      };
      this.getSocketId = function() {
        return WebRTC.prototype.getSocketId.apply(_this, arguments);
      };
      this.documentElement = documentElement;
      this.connection = io.connect(window.location.origin);
      desiredServer = this.getDesiredServer();
      this.connection.emit("joinAsClientBrowser", {
        "desiredServer": desiredServer
      });
      this.serverRTCPC = null;
      this.createServerConnection();
      this.createDataChannel();
      this.sendOffer(desiredServer);
      this.connection.on("receiveAnswer", this.receiveAnswer);
      this.connection.on("receiveICECandidate", this.receiveICECandidate);
      this.connection.on("setSocketId", function(socketId) {
        return _this.socketId = socketId;
      });
      this.htmlProcessor = new HTMLProcessor(this.sendEvent, this.setDocumentElementInnerHTML, this.getSocketId);
      this.eventTransmitter = new EventTransmitter();
      this.setUpReceiveEventCallbacks();
      contentWindow = document.getElementById("container").contentWindow;
      this.history = contentWindow.history;
      contentWindow.onpopstate = function(evt) {
        var filename;
        filename = evt.state.path;
        return _this.htmlProcessor.requestFile(filename, "backbutton");
      };
    }

    WebRTC.prototype.getSocketId = function() {
      return this.socketId;
    };

    WebRTC.prototype.getDesiredServer = function() {
      var pathname, suffix;
      pathname = window.location.pathname;
      if (pathname.indexOf("connect") === -1) {
        console.error("Error: pathname does not contain 'connect'");
      }
      suffix = pathname.substr("/connect/".length);
      if (suffix.indexOf("/") !== -1) {
        suffix = suffix.substr(0, suffix.indexOf("/"));
      }
      return suffix;
    };

    WebRTC.prototype.createDataChannel = function() {
      var _this = this;
      try {
        console.log("createDataChannel to server");
        this.dataChannel = this.serverRTCPC.createDataChannel("RTCDataChannel", {
          reliable: false
        });
        this.dataChannel.onopen = function() {
          console.log("data stream open");
          return _this.sendEvent("testEvent", {});
        };
        this.dataChannel.onclose = function(event) {
          return console.log("data stream close");
        };
        this.dataChannel.onmessage = function(message) {
          console.log("data stream message");
          return _this.eventTransmitter.receiveEvent(message.data);
        };
        return this.dataChannel.onerror = function(err) {
          return console.log("data stream error: " + err);
        };
      } catch (error) {
        return console.error("seems that DataChannel is NOT actually supported!");
      }
    };

    WebRTC.prototype.createServerConnection = function() {
      var _this = this;
      this.serverRTCPC = new mozRTCPeerConnection(null, {
        "optional": [
          {
            "RtpDataChannels": true
          }
        ]
      });
      return this.serverRTCPC.onicecandidate = function(event) {
        return _this.connection.emit("sendICECandidate", "server", event.candidate);
      };
    };

    WebRTC.prototype.sendOffer = function(desiredServer) {
      var _this = this;
      return this.serverRTCPC.createOffer(function(sessionDescription) {
        _this.serverRTCPC.setLocalDescription(sessionDescription);
        return _this.connection.emit("sendOffer", sessionDescription, desiredServer);
      });
    };

    WebRTC.prototype.receiveAnswer = function(sessionDescription) {
      return this.serverRTCPC.setRemoteDescription(new mozRTCSessionDescription(sessionDescription));
    };

    WebRTC.prototype.receiveICECandidate = function(candidate) {
      if (candidate) {
        candidate = new mozRTCIceCandidate(candidate);
        console.log(candidate);
        return this.serverRTCPC.addIceCandidate(candidate);
      }
    };

    WebRTC.prototype.sendEvent = function(eventName, data) {
      return this.eventTransmitter.sendEvent(this.dataChannel, eventName, data);
    };

    WebRTC.prototype.setUpReceiveEventCallbacks = function() {
      var _this = this;
      this.eventTransmitter.addEventCallback("initialLoad", function(data) {
        return _this.setDocumentElementInnerHTML(data, "initialLoad");
      });
      this.eventTransmitter.addEventCallback("textAreaValueChanged", this.setDocumentElementInnerHTML);
      return this.eventTransmitter.addEventCallback("receiveFile", this.htmlProcessor.receiveFile);
    };

    WebRTC.prototype.setDocumentElementInnerHTML = function(data, optionalInfo) {
      var html, path,
        _this = this;
      html = data.fileContents;
      path = data.filename;
      if (optionalInfo !== "backbutton") {
        this.history.pushState({
          "path": path
        }, path);
      }
      console.log(this.history.state);
      this.documentElement.innerHTML = "<img src='/client/loading.gif' />";
      return this.htmlProcessor.processHTML(html, function(processedHTML, scriptMapping) {
        _this.documentElement.innerHTML = processedHTML;
        return _this.executeScriptsCallback(scriptMapping);
      });
    };

    WebRTC.prototype.executeScriptsCallback = function(scriptMapping) {
      var filename, newScriptEl, oldScriptEl, scriptElements, _i, _len, _results;
      scriptElements = this.documentElement.getElementsByTagName("script");
      _results = [];
      for (_i = 0, _len = scriptElements.length; _i < _len; _i++) {
        oldScriptEl = scriptElements[_i];
        newScriptEl = document.createElement("script");
        newScriptEl.type = "text/javascript";
        filename = oldScriptEl.text || oldScriptEl.textContent || oldScriptEl.innerHTML || "";
        if (!scriptMapping[filename]) {
          console.error("BAD: " + filename + "was not found in the script mapping. Script will not exist. This is because the script name got encoding-bork.");
        }
        newScriptEl.text = scriptMapping[filename];
        oldScriptEl.parentNode.insertBefore(newScriptEl, oldScriptEl);
        _results.push(oldScriptEl.parentNode.removeChild(oldScriptEl));
      }
      return _results;
    };

    return WebRTC;

  })();

}).call(this);
